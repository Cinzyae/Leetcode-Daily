# 字符串



## 字符：520

### 520.[检测大写字母](https://leetcode-cn.com/problems/detect-capital/)

```java
class Solution {
    public boolean detectCapitalUse(String word) {
        char[] str = word.toCharArray();
        int n = str.length;
        int count = 0;
        if(isCapital(str[n-1])){
            for(int i=n-2;i>=0;i--){
                if(!isCapital(str[i])){
                    return false;
                }
            }
            return true;
        }else{
            for(int i=n-2;i>=1;i--){
                if(isCapital(str[i])){
                    return false;
                }
            }
            return true;
        }        
    }
    private boolean isCapital(char a){
        if(a>='A'&&a<='Z'){
            return true;
        }else{
            return false;
        }
    }
}
```

从后往前检索，若最后一个字母为大写，则前面字母需全为大写；若最后一个字母为小写，则除了第一个字母外所有字母需全为小写。



## 回文串的定义：125

###125.[验证回文串](https://leetcode-cn.com/problems/valid-palindrome/)

```java
class Solution {
    public boolean isPalindrome(String s) {
        int i = 0;
        int n = s.length();
        int j = n-1;
        String str = s.toLowerCase();
        while(i<=j){
            while(!ischar(str.charAt(i))&&i<j){
                i++;            
            }
            while(!ischar(str.charAt(j))&&i<j){
                j--;
            }
            if(str.charAt(i)==str.charAt(j)){
                i++;
                j--;
            }else{
                return false;
            }
        }
        return true;
    }
    private boolean ischar(char a){
        if((a>='0'&&a<='9')||(a>='a'&&a<='z')){
            return true;
        }else{
            return false;
        }
    }
}
```

转化为小写，ischar()方法判断是否为数字和字符，双指针分别从头尾开始，碰到不符合条件的就++/--，直到指针相遇。

### 14.[最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)

```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        int len = strs.length;
        int minlen = 200;
        int flag = 0;
        String res = "";
        for(int i = 0;i<len;i++){
            minlen = Math.min(minlen,strs[i].length());
        }
        for(int i = 0;i<minlen&&flag==0;i++){
            char temp = strs[0].charAt(i);
            for(int j = 1;j<len;j++){
                if(strs[j].charAt(i)!= temp){
                    flag = 1;
                    break;
                }
            }
            if(flag==0){
                res += temp;
            }                
        }
            return res;
    }
}
```

一个一个比较即可





## 单词：434、58

### 434.[字符串中的单词数](https://leetcode-cn.com/problems/number-of-segments-in-a-string/)

```java
class Solution {
    public int countSegments(String s) {
        int count = 0;
        int len = s.length();
        for(int i=0;i<len-1;i++){
            if(!isSpace(s.charAt(i))&&isSpace(s.charAt(i+1))){
                count++;
            }
        }
        if(len>0){
            if(!isSpace(s.charAt(len-1))){
            count++;
        }
        }      
        return count;
    }
    private boolean isSpace(char a){
        return a==' ';
    }
}
```

当碰到单词结尾count++，单独统计最后一个单词，注意越界问题即可。



### 58.[最后一个单词的长度](https://leetcode-cn.com/problems/length-of-last-word/)

```java
class Solution {
    public int lengthOfLastWord(String s) {
        int count = 0;
        int len = s.length();
        int i = 0;
        for(i = len-1;i>=0;i--){
            if(isArt(s.charAt(i))){
                count++;
                for(int j=i-1;j>=0;j--){
                    if(isArt(s.charAt(j))){
                        count++;
                    }else{
                        break;
                    }
                }
                break;
            }
        }
        return count;
    }
    private boolean isArt(char a){
        return (a >= 'a' && a <= 'z') || (a >= 'A' && a <= 'Z');
    }
}
```

从后向前统计，遇到第一个字母标记同时count++，从这个位置继续遍历，碰到字母count++，碰到空格直接break，最后count即是结果。



## 字符串的反转：344、541、557、151

### 344.[反转字符串](https://leetcode-cn.com/problems/reverse-string/)

```java
class Solution {
    public void reverseString(char[] s) {
        int len = s.length;
        int i = 0;
        int j = len-1;
        char temp;
        while(i<j){
            temp = s[i];
            s[i] = s[j];
            s[j] = temp;
            i++;
            j--;
        }
    }
}
```

没啥好说，直接换。



### 541.[反转字符串 II](https://leetcode-cn.com/problems/reverse-string-ii/)

```java
class Solution {
    public String reverseStr(String s, int k) {
        int n = s.length();
        char[] arr = s.toCharArray();
        for (int i = 0; i < n; i += 2 * k) {
            reverse(arr, i, Math.min(i + k, n) - 1);
        }
        return new String(arr);
    }
    private void reverse(char[] arr, int left, int right) {
        while (left < right) {
            char temp = arr[left];
            arr[left] = arr[right];
            arr[right] = temp;
            left++;
            right--;
        }
    }
}
```

直接换



### 557.[反转字符串中的单词 III](https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/)

```java
class Solution {
    public String reverseWords(String s) {
        int n = s.length();
        char[] arr = s.toCharArray();
        int i=0;
        int j=0;
        while(j<n){
            if(arr[j]==' '){
                reverse(arr,i,j-1);
                j++;
                i = j;
            }else{
                j++;
            }
        }
        reverse(arr,i,n-1);
        return new String(arr);
    }
    private void reverse(char[] str,int left,int right){
        char temp;
        while(left<right){
            temp = str[left];
            str[left] = str[right];
            str[right] = temp;
            left++;
            right--;
        }
    }
}
```

跟上题差不多。



### 151.[翻转字符串里的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)

```java
class Solution {
    public String reverseWords(String s) {
        s = s.trim();
        String[] str = s.split("\\s+");
        reverse(str,0,str.length-1);
        String res = String.join(" ",str);
        return res;
    }
    private void reverse(String[] str,int left,int right){
        String temp;
        while(left<right){
            temp = str[left];
            str[left] = str[right];
            str[right] = temp;
            left++;
            right--;
        }
    }

}
```

split后reverse再join。

![image-20220117224441866](C:\Users\朱源\AppData\Roaming\Typora\typora-user-images\image-20220117224441866.png)





## 字符的统计：387、389、383、242、49、451、423、657、551、696、467、535



### 387.[字符串中的第一个唯一字符](https://leetcode-cn.com/problems/first-unique-character-in-a-string/)

```java
class Solution {
    public int firstUniqChar(String s) {
        Map<Character,Integer> map = new HashMap<Character,Integer>();
        int n = s.length();
        int idx = n;
        for(int i=0;i<n;i++){
            if(map.containsKey(s.charAt(i))){
                map.put(s.charAt(i),n);
            }else{
                map.put(s.charAt(i),i);
            }
        }
        for(Character i:map.keySet()){
            idx = Math.min(map.get(i),idx);
        }
        idx = (idx==n?-1:idx);
        return idx;
    }
}
```

用hashmap储存字符出现的下标，若该字符第二次出现，则将其value改为n，最后遍历hashmap，最小的value即为答案。



### 389.[找不同](https://leetcode-cn.com/problems/find-the-difference/)

```java
class Solution {
    public char findTheDifference(String s, String t) {
        Map<Character,Integer> map = new HashMap<Character,Integer>();
        int n = s.length();
        for(int i=0;i<n;i++){
            char a = s.charAt(i);
            if(!map.containsKey(a)){
                map.put(a,1);
            }else{
                int temp1 = map.get(a);
                map.put(a,temp1+1);
            }
            
        }
        for(int i=0;i<n+1;i++){
            char b = t.charAt(i);
            if(!map.containsKey(b)){
                return t.charAt(i);
            }else{
                int temp2 = map.get(b);
                if(temp2==1){
                    map.remove(b);
                }else{
                    map.put(b,temp2-1);
                }
            }
        }
        for(Character c : map.keySet()){
            return c;
        }
        return 0;
    }
}
```

遍历s用hashmap储存频次，遍历t将频次减掉，最后剩下的就是多出来的。



### 383.[赎金信](https://leetcode-cn.com/problems/ransom-note/)

```java
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        int m = magazine.length();
        int n = ransomNote.length();
        Map<Character,Integer> map = new HashMap<Character,Integer>();
        for(int i=0;i<m;i++){
            char a = magazine.charAt(i);
            if(!map.containsKey(a)){
                map.put(a,1);
            }else{
                int temp = map.get(a);
                map.put(a,temp+1);
            }
        }
        for(int j=0;j<n;j++){
            char b = ransomNote.charAt(j);
            if(!map.containsKey(b)){
                return false;
            }else if(map.get(b)==1){
                map.remove(b);
            }else{
                int temp2 = map.get(b);
                map.put(b,temp2-1);
            }
        }
        return true;
    }
}
```

思路同上题，但参考题解直接用new int[26]来统计，好像比hashmap好一些。



### 242.[有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

```java
class Solution {
    public boolean isAnagram(String s, String t) {
        int m = s.length();
        if(m!=t.length()){
            return false;
        }
        int[] compare = new int[26];
        for(int i=0;i<m;i++){
            compare[s.charAt(i)-'a']++;
            compare[t.charAt(i)-'a']--;
        }
        for(int i=0;i<26;i++){
            if(compare[i]!=0){
                return false;
            }
        }
        return true;
    }
}
```

用new int[26]统计，上题的参考思路。



### 49.[字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        HashMap<String,ArrayList<String>> map=new HashMap<>();
        for(String s:strs){
            char[] ch=s.toCharArray();
            Arrays.sort(ch);
            String key=String.valueOf(ch);
            if(!map.containsKey(key))    map.put(key,new ArrayList<>());
            map.get(key).add(s);
        }
        return new ArrayList(map.values());
    }
}
```



### 451.[根据字符出现频率排序](https://leetcode-cn.com/problems/sort-characters-by-frequency/)

```java
class Solution {
    public String frequencySort(String s) {
        Map<Character,Integer> map = new HashMap<Character,Integer>();
        int len = s.length();
        int max = 0;
        char tempc = 'a';
        char[] res = new char[len];
        for(int i=0;i<len;i++){
            char a = s.charAt(i);
            if(map.containsKey(a)){
                int temp = map.get(a);
                map.put(a,temp+1);
            }else{
                map.put(a,1);
            }
        }
        int j=0;
        while(!map.isEmpty()){
            for(Character b :map.keySet()){
                int num = map.get(b);
                if(num>max){
                    max = num;
                    tempc = b;
                }
            }
            for(int k=0;k<max;k++){
                res[j+k] = tempc;
            }
            j+=max;
            map.remove(tempc);
            max = 0;
        }
        return String.valueOf(res);
    }
}
```

用hashmap记录出现次数，然后遍历hashmap即可。
