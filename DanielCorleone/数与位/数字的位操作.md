## [231. 2 的幂](https://leetcode-cn.com/problems/power-of-two/)

直接 n & n - 1 == 0即可

```java
class Solution {
    public boolean isPowerOfTwo(int n) {
        if (n <= 0) return false;
        return (n & n - 1) == 0;
    }
}
```

## [342. 4的幂](https://leetcode-cn.com/problems/power-of-four/)

先判断是否是2的幂，再判断是否是4的幂(模3为1)

```java
class Solution {
    public boolean isPowerOfFour(int n) {
        if (n <= 0) return false;
        if ((n & n - 1) != 0) return false; 
        return n % 3 == 1;
    }
}
```

## [326. 3 的幂](https://leetcode-cn.com/problems/power-of-three/)

沟吧题目考数学来的，直接循环来写了 : (

```java
class Solution {
    public boolean isPowerOfThree(int n) {
        if (n <= 0) return false;
        while (n != 1) {
            if (n % 3 != 0) return false;
            n = n / 3;
        } 
        return true;
    }
}
```

## [504. 七进制数](https://leetcode-cn.com/problems/base-7/)

### 思路

辗转相除法即可

```java
class Solution {
    public String convertToBase7(int num) {
        if (num == 0) return "0";
        StringBuffer sb = new StringBuffer();
        boolean flag = false;
        if (num < 0) {
            flag = true;
            num = Math.abs(num);
        }
        while (num != 0) {
            sb.append(num % 7);
            num = num / 7;
        }
        if (flag) sb.append('-');
        return sb.reverse().toString();
    }
}
```

## [263. 丑数](https://leetcode-cn.com/problems/ugly-number/)

### 思路

无脑除5，3，2即可，如果不等于1那就不是丑数

```java
class Solution {
    public boolean isUgly(int n) {
       if (n == 0) return false;
       while (n % 5 == 0) n /= 5;
       while (n % 3 == 0) n /= 3;
       while (n % 2 == 0) n = n >> 1;
       return n == 1; 
    }
}
```

## [190. 颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits/)

### 思路

1.直接调用api

Integer.reverse()

2.模拟

```java
public class Solution {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
        int res = 0;
        for (int i = 0; i < 32 && n != 0; i++) {
            res |= (n & 1) << (31 - i);
            n = n >>> 1;
        }
        return res;
    }
}
```



## [191. 位1的个数](https://leetcode-cn.com/problems/number-of-1-bits/)

### 思路

和n -1取与，就可以消掉最低位以后的0

```java
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int res = 0;
        while (n != 0) {
            n = n & n - 1;
            res++;
        }
        return res;
    }
}
```

## [476. 数字的补数](https://leetcode-cn.com/problems/number-complement/)

### 思路

其实就是取反码的意思，做法：找出第一个大于n的二次幂，然后将n和这个数-1取异或。

```java
class Solution {
    public int findComplement(int num) {
        long temp = 1;
        while (temp <= num) temp = temp << 1;
        return (int) (num ^ (temp - 1));
    }
}
```

## [461. 汉明距离](https://leetcode-cn.com/problems/hamming-distance/)

### 思路

取异或，然后计算异或结果中1的位数即可。

```java
class Solution {
    public int hammingDistance(int x, int y) {
        int cnt = x ^ y;
        int res = 0;
        while (cnt != 0) {
            if ((cnt & 1) == 1) res++;
            cnt = cnt >> 1;
        }
        return res;
    }
}
```

 

