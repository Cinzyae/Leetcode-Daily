## [594. 最长和谐子序列](https://leetcode-cn.com/problems/longest-harmonious-subsequence/)

使用Map统计每个数出现的次数即可。

因为结果集是要求子序列，可以不连续。

```java
class Solution {
    public int findLHS(int[] nums) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);
        }

        int res = 0;
        for (int key : map.keySet()) {
            int cur = map.get(key);
            if (map.containsKey(key + 1)) {
                res = Math.max(res, cur + map.get(key + 1));
            }
        }
        return res;
    }
}
```

或者，也可以排序后用双指针统计。

## [350. 两个数组的交集 II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/)

用两个Map取二者最小即可。

```java
class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        List<Integer> list = new ArrayList<>();
        Map<Integer, Integer> map1 = new HashMap<>();
        Map<Integer, Integer> map2 = new HashMap<>();
        for (int i = 0; i < nums1.length; i++) {
            map1.put(nums1[i], map1.getOrDefault(nums1[i], 0) + 1);
        }

        for (int i = 0; i < nums2.length; i++) {
            map2.put(nums2[i], map2.getOrDefault(nums2[i], 0) + 1);
        }

        for (int key : map1.keySet()) {
            if (map2.containsKey(key)) {
                int i = Math.min(map1.get(key), map2.get(key));
                for (int j = 0; j < i; j++) list.add(key);
            }
        }

        int[] arr = new int[list.size()];
        for (int i = 0; i < list.size(); i++) arr[i] = list.get(i);
        return arr;
    }  
}
```

用一个map也行,用掉一个就减一次。

```java
class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        if (nums1.length > nums2.length) return intersect(nums2, nums1);
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums1.length; i++) {
            map.put(nums1[i], map.getOrDefault(nums1[i], 0) + 1);
        }
        List<Integer> list = new ArrayList<>();
        for (int elem : nums2) {
            if (map.containsKey(elem)) {
                int cnt = map.get(elem);
                if (cnt >= 1) {
                    list.add(elem);
                    cnt--;
                    if (cnt > 0) map.put(elem, cnt);
                    else map.remove(elem);
                }
            }
        }

        int[] arr = new int[list.size()];
        for (int i = 0; i < list.size(); i++) arr[i] = list.get(i);
        return arr;
    }
}
```

## [554. 砖墙](https://leetcode-cn.com/problems/brick-wall/)

### 思路

记录每个空隙所在位置的次数。最优解就会是：总行数减去最大的空隙数。

![image-20220123234433466](https://gitee.com/daniel2001/picture-bed/raw/master/image-20220123234433466.png)

```java
class Solution {
    public int leastBricks(List<List<Integer>> wall) {
        Map<Integer,Integer> map = new HashMap<>();
        for (int i = 0; i < wall.size(); i++) {
            int pre = 0;
            for (int j = 0; j < wall.get(i).size(); j++) {
                pre += wall.get(i).get(j);
                map.put(pre, map.getOrDefault(pre, 0) + 1);
            }
            map.remove(pre); // 删掉最末尾。
        }

        int res = wall.size(), n = wall.size();
        for (int key : map.keySet()) {
            int value = map.get(key);
            res = Math.min(res, n - value);
        }
        return res;
    } 
}
```

