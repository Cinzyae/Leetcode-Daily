## [217. 存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/)

### 思路

猪鼻方法，手写快排

```java
class Solution {
    public boolean containsDuplicate(int[] nums) {
        int n = nums.length;
        quick(nums, 0, n -1);
        for (int i = 1; i < n; i++) {
            if (nums[i] == nums[i-1]) return true;
        }
        return false;
    }

    public void quick(int[] nums, int l, int r) {
        if (l >= r) return;
        int i = l - 1, j = r + 1;
        int cur = nums[(l + r) / 2];
        while (i < j) {
            do {
                i++;
            } while (nums[i] < cur);

            do {
                j--;
            } while (nums[j] > cur);

            if (i < j) {
                int temp = nums[i];a
                nums[i] = nums[j];
                nums[j] = temp;
            }
        }

        quick(nums, l, j);
        quick(nums, j+1, r);
    }
}
```

最优解，哈希Set

```java
class Solution {
    public boolean containsDuplicate(int[] nums) {
        Set<Integer> s = new HashSet<>();
        for (int i = 0; i < nums.length; i++) {
            if (!s.add(nums[i])) return true;
        }
        return false;
    }
}
```

## [633. 平方数之和](https://leetcode-cn.com/problems/sum-of-square-numbers/)

### 思路

根据平方差公式

$a^2 + b ^2 + 2ab = (a + b) ^ 2$

很容易证出来最大可能的数是 $\sqrt c$​

所以从1和根号c开始向内逼近即可

```java
class Solution {
    public boolean judgeSquareSum(int c) {
        long i = 1, j = (long)Math.sqrt(c);
        while (i <= j) {
            long cur = i * i + j * j;
            if (cur == c) return true;
            else if (cur > c) j--;
            else i++; 
        }
        return false;
    }
}
```

## [349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

### 思路

将数组元素丢到set里面就可以了

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        int m = nums1.length, n = nums2.length;
        Set<Integer> r = new HashSet<>();
        Set<Integer> set = new HashSet<>();
        if (m < n) {
            for (int i = 0; i < m; i++) set.add(nums1[i]);

            for (int i = 0; i < n; i++) {
                if (set.contains(nums2[i])) r.add(nums2[i]);
            }
        } else {
            for (int i = 0; i < n; i++) set.add(nums2[i]);

            for (int i = 0; i < m; i++) {
                if (set.contains(nums1[i])) r.add(nums1[i]);
            }
        }
        int[] res = new int[r.size()];
        int cnt = 0;
        for (int i : r) {
            res[cnt++] = i;
        }
        return res;
    }
}
```

#### [128. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)

### 思路

- 先用set存每个元素
- 遍历数组，将当前的元素从set删掉，同时将当前元素相邻的元素也全都删掉，并维护结果

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        Set<Integer> set = new HashSet<>();
        for (int elem : nums) set.add(elem);

        int n = nums.length;
        int res = 0;
        for (int i = 0; i < n; i++) {
            if (set.remove(nums[i])) {
                int cur = nums[i];
                int l = i, r = i;
                while (set.remove(--cur)) l--;
                cur = nums[i];
                while (set.remove(++cur)) r++;
                res = Math.max(res, r - l + 1);
            }
        }
        return res;
    }

}
```

## [202. 快乐数](https://leetcode-cn.com/problems/happy-number/)

### 思路

列了几个之后就发现，如果不是快乐数，那么就会在几个数字之间重复。

那这就很简单了，用set来存已经得到过的数字，如果再出现这个数字，势必会进入循环，无法变成1.

```java
class Solution {
    public boolean isHappy(int n) {
        Set<Integer> set = new HashSet<>();
        while (n != 1) {
            n = getN(n);
            if (set.contains(n)) return false;
            set.add(n);
        }
        return true;
    }

    public int getN(int n) {
        int res = 0;
        while (n != 0) {
            int cur = n % 10;
            res += cur * cur;
            n /= 10;
        }
        return res;
    }
}
```

## [500. 键盘行](https://leetcode-cn.com/problems/keyboard-row/)

```java
class Solution {
    public String[] findWords(String[] words) {
        String map = "12210111011122000010020202";
        List<String> r = new ArrayList<>();
        for (int i = 0; i < words.length; i++) {
            String cur = words[i];
            int pre = map.charAt(cur.toLowerCase().charAt(0) - 'a');
            boolean canAdd = true;
            for (int j = 0; j < cur.length(); j++) {
                if (map.charAt(cur.toLowerCase().charAt(j) - 'a') != pre)  canAdd = false;
            }

            if (canAdd) r.add(cur);
        }

        String[] res = new String[r.size()];
        for (int i = 0; i < r.size(); i++) res[i] = r.get(i);
        return res;
    }
}
```

## [290. 单词规律](https://leetcode-cn.com/problems/word-pattern/)

### 思路

记录char-String的映射。

但是这是不够的，比如不同的key都对应了相同的value

**"abc"  "dog cat dog"**

那怎么办？总不能每次都要遍历map把(map.containsValue())

太暴力了，那就用个set存value~

- 如果不存在某个key，那么就加进去。同时查一下set看是否有了这个value。如果有了这个value，就说明不对
- 如果key已经存在，判断value相等不相等即可

```java
class Solution {
    public boolean wordPattern(String pattern, String s) {
        String[] str = s.split(" ");
        if (str.length != pattern.length()) return false;
        Map<Character, String> map = new HashMap<>();
        Set<String> set = new HashSet<>();
        for (int i = 0; i < pattern.length(); i++) {
            char c = pattern.charAt(i);
            if (map.containsKey(c)) {
                if (!map.get(c).equals(str[i])) return false;
            } else {
                map.put(c, str[i]);
                if (set.contains(str[i])) return false;
                set.add(str[i]);
            }
            
        }

        return true;
    }
}
```

## [532. 数组中的 k-diff 数对](https://leetcode-cn.com/problems/k-diff-pairs-in-an-array/)

### 思路

- 先用map存每个数出现的次数。
- 虽然是求绝对值为k，但可以遍历map的keySet()，找map是否存在$key1 + k= key2$的key2。这样我们找的就是数对左边的元素，避免了绝对值的多种情况
- 注意k=0的情况，这时候只统计出现次数大于1的key即可

```java
class Solution {
    public int findPairs(int[] nums, int k) {
        Map<Integer,Integer> map = new HashMap<>();
        for (int elem : nums) {
            if (map.containsKey(elem)) map.put(elem, map.get(elem) + 1);
            else map.put(elem, 1);
        }

        int res = 0;
        for (int key : map.keySet()) {
            if (k == 0) {
                if (map.get(key) > 1) res++;
            } else if (map.containsKey(key + k)) res++;
        }
        return res;
    }
}
```



## [205. 同构字符串](https://leetcode-cn.com/problems/isomorphic-strings/)

### 思路

和上面的290.单词规律是一样的

```java
class Solution {
    public boolean isIsomorphic(String s, String t) {
        if (s.length() != t.length()) return false;
        Map<Character, Character> map = new HashMap<>();
        Set<Character> set = new HashSet<>();
        for (int i = 0; i < s.length(); i++) {
            char key = s.charAt(i);
           if (map.containsKey(key)) {
               if (!map.get(key).equals(t.charAt(i))) return false;
           } else {
               map.put(key, t.charAt(i));
               if (set.contains(t.charAt(i))) return false;
               set.add(t.charAt(i));
           }
        }
        return true;
    }
}
```

## [166. 分数到小数](https://leetcode-cn.com/problems/fraction-to-recurring-decimal/)

### 思路

建立余数和所在位置的map映射即可

```java
class Solution {
    public String fractionToDecimal(int numerator, int denominator) {
        StringBuffer sb = new StringBuffer();
        long a = numerator, b = denominator;
        if (a % b == 0) return String.valueOf(a / b);
        if (a * b < 0) sb.append('-');
        a = Math.abs(a);
        b = Math.abs(b);
        sb.append(a / b + ".");
        a %= b;

        Map<Long, Integer> map = new HashMap<>();
        while (a != 0) {
            map.put(a, sb.length());
            a *= 10;
            sb.append(a / b);
            a %= b;

            if (map.containsKey(a)) {
                int v = map.get(a);
                return String.format("%s(%s)", sb.substring(0, v), sb.substring(v));
            }
        }

        return sb.toString(); 
    }
}
```

