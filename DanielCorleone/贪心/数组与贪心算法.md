[toc]

## [605. 种花问题](https://leetcode-cn.com/problems/can-place-flowers/)

### 思路

- 贪心的种花(连续三个0)即可，比较恶心的事边界问题。

```java
class Solution {
    public boolean canPlaceFlowers(int[] flowerbed, int n) {
        for (int i = 0; i < flowerbed.length; i++) {
            if (flowerbed[i] == 0
            && (i == 0 || flowerbed[i - 1] == 0)
            && (i == flowerbed.length - 1 || flowerbed[i + 1] == 0)) {
                flowerbed[i] = 1;
                n--;
            }
        }
        return n <= 0;
    }
}
```

## [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

### 思路

- 贪心，每天都打算当天买掉，只需要记录今天之前的最小值，那么就能逐渐递推得到最大值。

```java
class Solution {
    public int maxProfit(int[] prices) {
        int min = Integer.MAX_VALUE;
        int res = Integer.MIN_VALUE;
        for (int price : prices) {
            min = Math.min(min, price);
            res = Math.max(res, price - min);
        }
        return res;
    }
}
```

## [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

 ### 思路

- 贪心，如果今天的比前一天的要大，也就是能赚钱，那就直接卖掉。

```java
class Solution {
    public int maxProfit(int[] prices) {
        int res = 0;
        int pre = prices[0];
        for (int i = 0; i < prices.length; i++) {
            if (prices[i] > pre) {
                res += prices[i] - pre;
            }
            pre = prices[i];
        }
        return res;
    } 
}
```

## [561. 数组拆分 I](https://leetcode-cn.com/problems/array-partition-i/)

### 思路

- 排完序后直接贪心，取二者中小的一个即可

```java
class Solution {
    public int arrayPairSum(int[] nums) {
        quick(nums, 0, nums.length - 1);
        int res = 0;
        int n = nums.length;
        for (int i = 0; i < n; i+= 2) {
            res += nums[i];
        }
        return res;
    }

    public void quick(int[] nums, int l, int r) {
        if (l >= r) return;

        int cur = nums[(l + r) / 2];
        int i = l - 1, j = r + 1;

        while (i < j) {
            do {
                i++;
            } while (nums[i] < cur);

            do {
                j--;
            } while (nums[j] > cur);

            if (i < j) {
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
            }
        }

        quick(nums, l, j);
        quick(nums, j + 1, r); 
    }
}
```

## [455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/)

### 思路

- 贪心~ 直接排序，从小到大分配即可

```java
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        int res = 0;
        Arrays.sort(g);
        Arrays.sort(s);
        int p1 =0, p2 = 0;
        while (p1 < g.length && p2 < s.length) {
            if (s[p2] >= g[p1]) {
                res++;
                p1++;
                p2++;
            } else {
                p2++;
            }
        }
        return res;
    }
}
```

